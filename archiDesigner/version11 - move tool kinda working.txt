<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D CAD to 3D Real-time Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-main: #000000;
            --bg-panel: #111111;
            --border-color: #2a2a2a;
            --text-primary: #e0e0e0;
            --text-secondary: #888888;
            --accent-color: #0d6efd;
            --accent-hover: #3b82f6;
            --danger-color: #dc3545;
            --danger-hover: #ef4444;
            --success-color: #198754;
            --resizer-color: #333333;
            --resizer-hover-color: var(--accent-color);
        }

        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: var(--bg-main);
            color: var(--text-primary);
        }

        #main-container { 
            display: flex; 
            width: 100vw; 
            height: 100vh; 
        }
        
        #layers-sidebar, #json-sidebar {
            background-color: var(--bg-panel);
            border-right: 1px solid var(--border-color);
            padding: 1rem;
            display: none; /* Initially hidden */
            flex-direction: column;
            flex-shrink: 0;
            z-index: 10;
            transition: width 0.3s ease;
        }
        #layers-sidebar {
            width: 240px;
        }
        #json-sidebar {
            width: 300px;
            border-right: none;
            border-left: 1px solid var(--border-color);
        }

        #layers-sidebar h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            padding-left: 0.5rem;
            color: var(--text-primary);
        }
        #canvas-list-container {
            flex-grow: 1;
            overflow-y: auto;
        }
        #canvas-list, .layer-group ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .layer-group ul {
            padding-left: 1rem;
            border-left: 1px solid var(--border-color);
            margin-left: 0.5rem;
            padding-top: 0.5rem;
        }
        .layer-group-header {
            font-weight: 600;
            font-size: 0.8rem;
            color: var(--text-secondary);
            padding: 0.25rem 0.5rem;
            margin-top: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        #canvas-list li {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 2px;
            border-left: 3px solid transparent;
        }
        #canvas-list li .canvas-name {
            flex-grow: 1;
        }
        #canvas-list li:hover {
            background-color: #222222;
            color: var(--text-primary);
        }
        #canvas-list li.active {
            background-color: rgba(13, 110, 253, 0.15);
            border-left: 3px solid var(--accent-color);
            color: var(--text-primary);
            font-weight: 500;
            padding-left: calc(0.5rem - 3px);
        }
        .layer-icon {
            margin-right: 0.5rem;
            width: 16px;
            height: 16px;
            color: var(--text-secondary);
            transition: color 0.2s;
        }
        .delete-layer-btn {
            display: none;
            color: var(--text-secondary);
            padding: 0.25rem;
        }
        #canvas-list li:hover .delete-layer-btn {
            display: block;
        }
        .delete-layer-btn:hover {
            color: var(--danger-color);
        }
        #canvas-list li:hover .layer-icon {
            color: var(--text-primary);
        }
        li.active .layer-icon, li.active:hover .layer-icon {
            color: var(--text-primary);
        }
        #sidebar-footer {
            padding-top: 0.5rem;
            margin-top: 0.5rem;
            border-top: 1px solid var(--border-color);
        }
        #add-layer-btn {
            width: 100%;
            padding: 0.6rem;
            border-radius: 0.375rem;
            border: 1px solid #444;
            background-color: #222;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-weight: 500;
        }
        #add-layer-btn:hover {
            background-color: #333;
            border-color: #555;
        }

        #content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #toolbar { 
            padding: 0.5rem 1rem; 
            border-bottom: 1px solid var(--border-color); 
            background-color: var(--bg-panel); 
            display: flex; 
            gap: 0.5rem; 
            align-items: center; 
            flex-shrink: 0;
        }
        #toolbar button {  
            padding: 0.5rem 0.75rem; 
            border-radius: 0.375rem; 
            border: 1px solid #444; 
            background-color: #222; 
            color: var(--text-primary); 
            cursor: pointer; 
            transition: all 0.2s ease-in-out; 
            display: flex; 
            align-items: center; 
            gap: 0.5rem;  
            font-size: 0.875rem;
            font-weight: 500;
        }
        #toolbar button:hover { 
            background-color: #333; 
            border-color: #555; 
        }
        #toolbar button.active { 
            background-color: var(--accent-color); 
            color: #ffffff; 
            border-color: var(--accent-color); 
        }
        #toolbar button.delete-btn {
            border-color: var(--danger-color);
            color: var(--danger-color);
            background-color: transparent;
        }
        #toolbar button.delete-btn:hover {
            background-color: var(--danger-color);
            color: white;
        }
        #toolbar button.delete-btn:hover svg {
            color: white;
        }

        .tool-separator {
            width: 1px;
            height: 24px;
            background-color: var(--border-color);
            margin: 0 0.5rem;
        }
        
        #curve-options {
            display: none; /* Initially hidden */
            align-items: center;
            gap: 0.5rem;
            margin-left: 0.5rem;
        }
        #curve-options label {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }
        #curve-options input {
            background-color: #000;
            border: 1px solid #444;
            color: var(--text-primary);
            border-radius: 0.25rem;
            padding: 0.25rem 0.5rem;
            width: 60px;
        }


        #editor-area {
            display: flex;
            flex: 1;
            background-color: var(--bg-main);
            overflow: hidden;
            position: relative;
        }

        #panel-2d-container {
            flex: 1 1 50%;
            display: flex;
            flex-direction: column;
            position: relative;
            min-width: 200px;
            background-color: var(--bg-main);
        }
        
        #canvas-container { 
            flex-grow: 1; 
            position: relative; 
            overflow: hidden; 
        }
        #drawing-canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
            cursor: crosshair; 
        }
        
        #wall-editor {
            width: 280px;
            background-color: var(--bg-panel);
            border-left: 1px solid var(--border-color);
            display: none; /* Toggled by JS */
            flex-direction: column;
            flex-shrink: 0;
        }
        #wall-editor-content {
            padding: 1rem;
            flex-grow: 1;
        }
        #wall-editor h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
        }
        .input-group {
            margin-bottom: 1rem;
        }
        #wall-editor label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
        }
        #wall-editor input {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.25rem;
            background-color: #000;
            border: 1px solid #444;
            color: var(--text-primary);
        }
        #wall-editor-footer {
            padding: 1rem;
            border-top: 1px solid var(--border-color);
        }
        #editor-tool-delete {
            width: 100%;
            padding: 0.6rem;
            border-radius: 0.375rem;
            border: 1px solid var(--danger-color);
            background-color: transparent;
            color: var(--danger-color);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-weight: 500;
        }
        #editor-tool-delete:hover {
            background-color: var(--danger-color);
            color: white;
        }
        
        #panel-3d { 
            flex: 1 1 50%;
            display: flex;
            flex-direction: column;
            position: relative; 
            min-width: 200px;
            background-color: var(--bg-main);
        }
        #renderer-container { 
            flex-grow: 1;
            position: relative;
        }
        
        .resizer {
            background-color: var(--resizer-color);
            cursor: col-resize;
            height: 100%;
            width: 5px;
            z-index: 5;
        }
        .resizer:hover {
            background-color: var(--resizer-hover-color);
        }
        
        .info-box { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(0,0,0,0.6); 
            color: var(--text-primary);
            padding: 8px 12px; 
            border-radius: 6px; 
            font-size: 0.8rem; 
            pointer-events: none; 
            border: 1px solid var(--border-color);
            backdrop-filter: blur(4px);
        }

        #material-editor, #global-settings-panel {
            position: absolute;
            background: rgba(17, 17, 17, 0.8);
            backdrop-filter: blur(5px);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            width: 240px;
            display: none;
            z-index: 20;
        }
        #material-editor {
            top: 10px;
            right: 10px;
        }
        #global-settings-panel {
            top: 50px; /* Adjusted position */
            right: 10px;
            left: auto;
        }
        #material-editor h3, #global-settings-panel h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        #material-editor .input-group, #global-settings-panel .input-group {
            margin-bottom: 0.75rem;
        }
        #material-editor label, #global-settings-panel label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
            display: block;
        }
        #material-editor input[type="color"] {
            width: 100%;
            height: 30px;
            border: none;
            padding: 0;
            background: none;
            cursor: pointer;
        }
        #material-editor input[type="range"], #global-settings-panel input[type="range"] {
            width: 100%;
        }

        #json-sidebar .json-editor-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        #json-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 0 1rem 0.5rem;
            color: var(--text-primary);
            font-size: 1rem;
            font-weight: 600;
        }
        #json-editor {
            flex-grow: 1;
            width: 100%;
            background-color: #0a0a0a;
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            padding: 0.5rem;
            font-family: monospace;
            font-size: 0.8rem;
            resize: none;
        }
        #json-editor:focus {
            outline: 1px solid var(--accent-color);
        }
        #json-editor::-webkit-scrollbar {
            width: 8px;
        }
        #json-editor::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        #json-editor::-webkit-scrollbar-thumb {
            background-color: #444;
            border-radius: 4px;
            border: 2px solid #1a1a1a;
        }
        
        .modal-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7); z-index: 99; 
            display: none; justify-content: center; align-items: center;
        }
        .modal-content {
            background: var(--bg-panel); color: var(--text-primary);
            padding: 1.5rem; border-radius: 0.5rem;
            width: 400px;
            border: 1px solid var(--border-color);
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .modal-content h3 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; }
        .modal-content label { display: block; margin-bottom: 0.5rem; }
        .modal-content input { width: 100%; padding: 0.5rem; border-radius: 0.25rem; background-color: #000; border: 1px solid #444; color: var(--text-primary); }
        .modal-actions { margin-top: 1.5rem; display: flex; justify-content: flex-end; gap: 0.5rem; }
        .modal-actions button { padding: 0.5rem 1rem; border-radius: 0.25rem; border: 1px solid transparent; cursor: pointer; transition: background-color 0.2s; font-weight: 500;}
        .modal-actions .btn-primary { background-color: var(--accent-color); color: white; border-color: var(--accent-color); }
        .modal-actions .btn-primary:hover { background-color: var(--accent-hover); }
        .modal-actions .btn-secondary { background-color: #333; color: var(--text-primary); border-color: #555;}
        .modal-actions .btn-secondary:hover { background-color: #444; }

        #canvas-top-right-controls, #viewport-top-right-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            display: flex;
            gap: 0.5rem;
        }
        #canvas-top-right-controls button, #viewport-top-right-controls button, #json-editor-header button {
            background-color: var(--bg-panel);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        #canvas-top-right-controls button:hover, #viewport-top-right-controls button:hover, #json-editor-header button:hover {
            background-color: #222;
            border-color: #444;
        }
        #loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            z-index: 20;
            display: none;
            font-size: 0.875rem;
        }
        #generate-floorplan-btn {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background-color: var(--accent-color);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            display: none;
        }
        #generate-floorplan-btn:hover {
            background-color: var(--accent-hover);
        }

        /* 3D Viewport Toolbar */
        #viewport-toolbar {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 1px;
            background-color: #222;
            border-radius: 0.375rem;
            border: 1px solid var(--border-color);
            z-index: 15;
            overflow: hidden;
        }
        #viewport-toolbar button {
            background-color: var(--bg-panel);
            border: none;
            color: var(--text-secondary);
            padding: 0.6rem;
            transition: all 0.2s;
        }
        #viewport-toolbar button:hover {
            background-color: #2a2a2a;
            color: var(--text-primary);
        }
        #viewport-toolbar button.active {
            background-color: var(--accent-color);
            color: white;
        }
    </style>
</head>
<body>

    <div id="main-container">
        <div id="layers-sidebar">
            <h3>Layers</h3>
            <div id="canvas-list-container">
                <ul id="canvas-list"></ul>
            </div>
            <div id="sidebar-footer">
                <button id="add-layer-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-plus-lg" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2z"/></svg>
                    Add Layer
                </button>
            </div>
        </div>
        
        <!-- Main Content -->
        <div id="content-area">
            <!-- Toolbar -->
            <div id="toolbar">
                 <button id="tool-settings" title="Global Settings">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-gear-fill" viewBox="0 0 16 16"><path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311a1.464 1.464 0 0 1 .872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1-.872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1-.872-2.105l.34-.1c1.4-.413-1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1 .872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/></svg>
                </button>
                 <div class="tool-separator"></div>
                <button id="tool-layers" title="Toggle Layers">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-stack" viewBox="0 0 16 16"><path d="M8 1.5l-7.5 4.219 7.5 4.219 7.5-4.219L8 1.5z"/><path d="M1 9.781L8 14l7-4.219V11.5a.5.5 0 0 1-1 0V9.781L8 12.281l-6-3.375v2.188a.5.5 0 0 1-1 0V9.781z"/></svg>
                </button>
                <div class="tool-separator"></div>
                <button id="tool-rectangle" title="Rectangle Wall Tool">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-square" viewBox="0 0 16 16"><path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/></svg>
                </button>
                <button id="tool-curve" title="Curve Wall Tool">
                   <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-vector-pen" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M10.646.646a.5.5 0 0 1 .708 0l4 4a.5.5 0 0 1 0 .708l-1.902 1.902-.829 3.313a1.5 1.5 0 0 1-1.024 1.024l-3.313.829-1.902 1.902a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 0-.708l1.902-1.902.829-3.313a1.5 1.5 0 0 1 1.024-1.024l3.313-.829L10.646.646zM11.5 2 10 3.5 8.5 2 7 3.5 5.5 2 4 3.5 2.5 2 1 3.5 2 5l1.5-1.5L5 5l1.5-1.5L8 5l1.5-1.5L11 5l1.5-1.5L14 5l1.5-1.5L14 2l-1.5 1.5L11.5 2z"/></svg>
                </button>
                <button id="tool-circle" title="Pillar/Circle Tool">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-circle" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/></svg>
                </button>
                <div id="curve-options">
                    <label for="curve-thickness-input">Thickness:</label>
                    <input type="number" id="curve-thickness-input" value="10" min="1">
                </div>
                <div class="tool-separator"></div>
                <button id="tool-clear" title="Clear All" class="delete-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg>
                    Clear All
                </button>
                <div class="ml-auto"></div>
                <button id="tool-json" title="Toggle JSON Editor">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-file-earmark-code" viewBox="0 0 16 16"><path d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5h-2z"/><path d="M8.646 6.646a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1 0 .708l-2 2a.5.5 0 0 1-.708-.708L10.293 8 8.646 6.354a.5.5 0 0 1 0-.708zm-1.292 0a.5.5 0 0 0-.708 0l-2 2a.5.5 0 0 0 0 .708l2 2a.5.5 0 0 0 .708-.708L5.707 8l1.647-1.646a.5.5 0 0 0 0-.708z"/></svg>
                    <span>JSON</span>
                </button>
            </div>

            <div id="editor-area">
                <!-- 2D Panel Container -->
                <div id="panel-2d-container">
                    <div id="canvas-container">
                        <div id="canvas-top-right-controls">
                            <button id="import-floorplan-btn" title="Import Floorplan">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-upload" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/></svg>
                            </button>
                            <button id="toggle-reference-btn" title="Toggle Reference Image" style="display: none;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-image" viewBox="0 0 16 16"><path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/><path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/></svg>
                            </button>
                        </div>
                        <div id="loading-indicator">Generating...</div>
                        <canvas id="drawing-canvas"></canvas>
                        <input type="file" id="floorplan-upload" accept="image/*" style="display: none;">
                        <button id="generate-floorplan-btn">Generate</button>
                    </div>
                    <!-- Properties Panel -->
                    <div id="wall-editor">
                        <div id="wall-editor-content">
                            <h3 id="editor-title">Edit Properties</h3>
                            <div class="input-group" id="group-wall-height">
                                <label for="wall-height-input">Height</label>
                                <input type="number" id="wall-height-input" value="50">
                            </div>
                             <div class="input-group" id="group-wall-thickness">
                                <label for="wall-thickness-input">Wall Thickness</label>
                                <input type="number" id="wall-thickness-input" value="10">
                            </div>
                            <div class="input-group" id="group-pillar-radius">
                                <label for="pillar-radius-input">Radius</label>
                                <input type="number" id="pillar-radius-input" value="20">
                            </div>
                            <div class="input-group" id="group-pillar-segments">
                                <label for="pillar-segments-input">Segments (Pattern)</label>
                                <input type="number" id="pillar-segments-input" value="32" min="3">
                            </div>
                        </div>
                        <div id="wall-editor-footer">
                             <button id="editor-tool-delete">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg>
                                Delete Shape
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Resizer -->
                <div class="resizer" id="resizer"></div>

                <!-- 3D Panel -->
                <div id="panel-3d">
                    <div id="renderer-container">
                        <div id="viewport-toolbar">
                            <button id="tool-translate" title="Translate (W)">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-arrows-move" viewBox="0 0 16 16">
                                    <path fill-rule="evenodd" d="M7.646.146a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1-.708.708L8.5 1.707V5.5a.5.5 0 0 1-1 0V1.707L6.354 2.854a.5.5 0 1 1-.708-.708l2-2zM8 10a.5.5 0 0 1 .5.5v3.793l1.146-1.147a.5.5 0 0 1 .708.708l-2 2a.5.5 0 0 1-.708 0l-2-2a.5.5 0 0 1 .708-.708L7.5 14.293V10.5A.5.5 0 0 1 8 10zM.146 8.354a.5.5 0 0 1 0-.708l2-2a.5.5 0 1 1 .708.708L1.707 7.5H5.5a.5.5 0 0 1 0 1H1.707l1.147 1.146a.5.5 0 0 1-.708.708l-2-2zM10 8a.5.5 0 0 1 .5-.5h3.793l-1.147-1.146a.5.5 0 0 1 .708-.708l2 2a.5.5 0 0 1 0 .708l-2 2a.5.5 0 0 1-.708-.708L14.293 8.5H10.5A.5.5 0 0 1 10 8z"/>
                                </svg>
                            </button>
                            <button id="tool-rotate" title="Rotate (E)">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-arrow-repeat" viewBox="0 0 16 16">
                                    <path d="M11.534 7h3.932a.25.25 0 0 1 .192.41l-1.966 2.36a.25.25 0 0 1-.384 0l-1.966-2.36a.25.25 0 0 1 .192-.41zm-11 2h3.932a.25.25 0 0 0 .192-.41L2.692 6.23a.25.25 0 0 0-.384 0L.342 8.59A.25.25 0 0 0 .534 9z"/>
                                    <path fill-rule="evenodd" d="M8 3c-1.552 0-2.94.707-3.857 1.818a.5.5 0 1 1-.771-.636A6.002 6.002 0 0 1 13.917 7H12.5A5.002 5.002 0 0 0 8 3zM3.1 9a5.002 5.002 0 0 0 8.757 2.182.5.5 0 1 1 .771.636A6.002 6.002 0 0 1 2.083 9H3.5z"/>
                                </svg>
                            </button>
                            <button id="tool-scale" title="Scale (R)">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-arrows-angle-expand" viewBox="0 0 16 16">
                                    <path fill-rule="evenodd" d="M5.828 10.172a.5.5 0 0 0-.707 0l-4.096 4.096V11.5a.5.5 0 0 0-1 0v3.975a.5.5 0 0 0 .5.5H4.5a.5.5 0 0 0 0-1H1.732l4.096-4.096a.5.5 0 0 0 0-.707zm4.344-4.344a.5.5 0 0 0 .707 0l4.096-4.096V4.5a.5.5 0 1 0 1 0V.525a.5.5 0 0 0-.5-.5H11.5a.5.5 0 0 0 0 1h2.768l-4.096 4.096a.5.5 0 0 0 0 .707z"/>
                                </svg>
                            </button>
                        </div>
                        <div id="viewport-top-right-controls">
                             <button id="download-fbx-btn" title="Download FBX">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-down" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M3.5 10.5a.5.5 0 0 1 .5.5v1a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 1 1 0v1a1.5 1.5 0 0 1-1.5 1.5h-8A1.5 1.5 0 0 1 2 12v-1a.5.5 0 0 1 .5-.5z"/><path fill-rule="evenodd" d="M7.646 12.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 11.293V1.5a.5.5 0 0 0-1 0v9.793L5.354 9.146a.5.5 0 1 0-.708.708l3 3z"/></svg>
                            </button>
                        </div>
                        <div id="global-settings-panel">
                            <h3>Global Model Settings</h3>
                             <div class="input-group">
                                <label for="height-adjustment-input">Height Adjustment</label>
                                <input type="number" id="height-adjustment-input" value="0">
                            </div>
                             <div class="input-group">
                                <label for="global-scale-input">Global Scale</label>
                                <input type="range" id="global-scale-input" min="0.1" max="2" step="0.05" value="1.0">
                            </div>
                        </div>
                        <div id="material-editor">
                            <h3>Material Properties</h3>
                            <div class="input-group">
                                <label for="material-color">Color</label>
                                <input type="color" id="material-color" value="#f0f0f0">
                            </div>
                             <div class="input-group">
                                <label for="material-roughness">Roughness</label>
                                <input type="range" id="material-roughness" min="0" max="1" step="0.01" value="0.7">
                            </div>
                             <div class="input-group">
                                <label for="material-metalness">Metalness</label>
                                <input type="range" id="material-metalness" min="0" max="1" step="0.01" value="0.0">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="json-sidebar">
            <div class="json-editor-container">
                <div id="json-editor-header">
                    <span>JSON Editor</span>
                    <button id="download-json-btn" title="Download JSON">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-download" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/></svg>
                    </button>
                </div>
                <textarea id="json-editor"></textarea>
            </div>
        </div>
    </div>

    <!-- Create Canvas Modal -->
    <div id="create-canvas-modal" class="modal-backdrop">
        <div class="modal-content">
            <h3>Create New Layer</h3>
            <label for="new-canvas-name">Layer Name</label>
            <input type="text" id="new-canvas-name" placeholder="e.g., Second Floor">
            <div class="modal-actions">
                <button id="cancel-create-canvas" class="btn-secondary">Cancel</button>
                <button id="confirm-create-canvas" class="btn-primary">Create</button>
            </div>
        </div>
    </div>


    <!-- Library Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/FBXExporter.js"></script>

    <!-- Main Application Script -->
    <script>
        // --- GLOBAL STATE ---
        let scene, camera, renderer, controls, wallGroup, transformControls;
        let layerGroups = [{
            height: 0,
            layers: [{ id: 0, name: 'Ground Floor', shapes: [], referenceImage: null, isVisible: true }]
        }];
        let currentCanvasId = 0;
        let referenceCanvasId = null;
        let selectedShape = null;
        let selected3DObject = null;
        let showReferenceImage = true;
        let outlinePass;
        const SNAP_POINT_RADIUS = 5;
        const SNAP_DISTANCE = 10;
        let scale = 1.0;
        const MIN_SCALE = 0.2;
        const MAX_SCALE = 5.0;
        let newCanvasData = {};
        let uploadedFloorplan = { data: null, type: null };
        let globalHeightAdjustment = 0;
        let globalModelScale = 1.0;

        // --- ACTION STATES ---
        let activeTool = 'rectangle'; // 'rectangle', 'curve', 'circle'
        let isDrawing = false;
        let isPannning = false;
        let isDraggingFromSnap = false;
        let isShiftPressed = false;
        let dragStartState = {};
        let activeSnapTarget = null;
        let hoveredSnapPoint = null;
        let curvePoints = [];
        let currentWallThickness = 10;
        let preTransformState = {};
        
        // Canvas Panning
        let panStart = { x: 0, y: 0 };
        let canvasOffset = { x: 0, y: 0 };

        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const panel2dContainer = document.getElementById('panel-2d-container');
        const canvasContainer = document.getElementById('canvas-container');
        const wallEditor = document.getElementById('wall-editor');
        const editorTitle = document.getElementById('editor-title');
        const wallHeightInput = document.getElementById('wall-height-input');
        const wallThicknessInput = document.getElementById('wall-thickness-input');
        const pillarRadiusInput = document.getElementById('pillar-radius-input');
        const pillarSegmentsInput = document.getElementById('pillar-segments-input');
        const groupWallHeight = document.getElementById('group-wall-height');
        const groupWallThickness = document.getElementById('group-wall-thickness');
        const groupPillarRadius = document.getElementById('group-pillar-radius');
        const groupPillarSegments = document.getElementById('group-pillar-segments');
        const canvasList = document.getElementById('canvas-list');
        const createCanvasModal = document.getElementById('create-canvas-modal');
        const newCanvasNameInput = document.getElementById('new-canvas-name');
        const panel3d = document.getElementById('panel-3d');
        const resizer = document.getElementById('resizer');
        const curveOptions = document.getElementById('curve-options');
        const curveThicknessInput = document.getElementById('curve-thickness-input');
        const materialEditor = document.getElementById('material-editor');
        const materialColorInput = document.getElementById('material-color');
        const materialRoughnessInput = document.getElementById('material-roughness');
        const materialMetalnessInput = document.getElementById('material-metalness');
        const jsonEditor = document.getElementById('json-editor');
        const jsonSidebar = document.getElementById('json-sidebar');
        const rendererContainer = document.getElementById('renderer-container');
        const floorplanUpload = document.getElementById('floorplan-upload');
        const importFloorplanBtn = document.getElementById('import-floorplan-btn');
        const toggleReferenceBtn = document.getElementById('toggle-reference-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        const generateFloorplanBtn = document.getElementById('generate-floorplan-btn');
        const settingsBtn = document.getElementById('tool-settings');
        const globalSettingsPanel = document.getElementById('global-settings-panel');
        const heightAdjustmentInput = document.getElementById('height-adjustment-input');
        const globalScaleInput = document.getElementById('global-scale-input');
        const downloadJsonBtn = document.getElementById('download-json-btn');
        const downloadFbxBtn = document.getElementById('download-fbx-btn');
        const jsonToolBtn = document.getElementById('tool-json');
        const layersSidebar = document.getElementById('layers-sidebar');
        const layersToolBtn = document.getElementById('tool-layers');
        const translateBtn = document.getElementById('tool-translate');
        const rotateBtn = document.getElementById('tool-rotate');
        const scaleBtn = document.getElementById('tool-scale');

        // --- HELPERS ---
        function getCanvasById(id) {
            for (const group of layerGroups) {
                const found = group.layers.find(c => c.id === id);
                if (found) return { canvas: found, group: group };
            }
            return null;
        }
        
        function getAllCanvases() {
            return layerGroups.flatMap(g => g.layers);
        }

        // --- 3D SCENE INITIALIZATION ---
        function createConcreteTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const context = canvas.getContext('2d');

            context.fillStyle = '#4a4a4a'; // Darker base for concrete
            context.fillRect(0, 0, 512, 512);

            for (let i = 0; i < 40000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 1.5;
                const gray = Math.floor(Math.random() * 25 + 50); // Darker speckles
                context.fillStyle = `rgb(${gray},${gray},${gray})`;
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fill();
            }
            return new THREE.CanvasTexture(canvas);
        }

        function init3D() {
            const container = document.getElementById('renderer-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111); // Dark gray background
            scene.fog = new THREE.Fog(0x111111, 1000, 4000);

            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 1, 5000);
            camera.position.set(200, 250, 350);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows

            container.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.screenSpacePanning = true;

            const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 0.8 ); // Softer ambient light
            hemiLight.position.set( 0, 300, 0 );
            scene.add( hemiLight );

            const dirLight = new THREE.DirectionalLight(0xfff0e1, 1.5); // Warmer sunlight
            dirLight.position.set(-300, 400, 200);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -1500;
            dirLight.shadow.camera.right = 1500;
            dirLight.shadow.camera.top = 1500;
            dirLight.shadow.camera.bottom = -1500;
            dirLight.shadow.camera.far = 5000;
            dirLight.shadow.bias = -0.0001;
            scene.add(dirLight);

            const groundTexture = createConcreteTexture();
            groundTexture.wrapS = THREE.RepeatWrapping;
            groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(20, 20);
            const groundMat = new THREE.MeshStandardMaterial({ map: groundTexture, roughness: 0.8, metalness: 0.1 });
            
            const groundGeo = new THREE.PlaneGeometry(5000, 5000);
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.userData.isGround = true; // Mark ground for click detection
            scene.add(ground);
            
            wallGroup = new THREE.Group();
            scene.add(wallGroup);
            
            // Transform Controls
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value;
            });
            transformControls.addEventListener('mouseDown', onTransformStart);
            transformControls.addEventListener('mouseUp', onTransformEnd);
            scene.add(transformControls);
            
            renderer.domElement.addEventListener('dblclick', on3DViewDblClick);
            renderer.domElement.addEventListener('contextmenu', on3DViewRightClick);
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- 2D CANVAS INITIALIZATION & DRAWING ---
        function init2D() {
            resizeCanvas();
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseLeave);
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            canvas.addEventListener('wheel', onCanvasWheel);
            canvas.addEventListener('dblclick', onDoubleClick);
        }

        function resizeCanvas() {
            const rect = canvasContainer.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            drawAllShapes();
        }
        
        function getSnapPoints(shape) {
            const points = [];
            if (shape.type === 'curve' || shape.type === 'circle') {
                // No snapping for curves or circles for now
            } else { // Rectangle and legacy walls
                for (let i = 0; i < shape.points.length; i++) {
                    const p1 = shape.points[i];
                    const p2 = shape.points[(i + 1) % shape.points.length];
                    points.push({
                        x: (p1.x + p2.x) / 2,
                        y: (p1.y + p2.y) / 2,
                        parentId: shape.id
                    });
                }
            }
            return points;
        }

        function drawAllShapes() {
            const result = getCanvasById(currentCanvasId);
            if (!result) return;
            const currentCanvas = result.canvas;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvasOffset.x, canvasOffset.y);
            ctx.scale(scale, scale);

            // --- Draw Reference Image ---
            if (currentCanvas.referenceImage && showReferenceImage) {
                ctx.globalAlpha = 0.5;
                ctx.drawImage(currentCanvas.referenceImage, 0, 0, currentCanvas.referenceImage.width, currentCanvas.referenceImage.height);
                ctx.globalAlpha = 1.0;
            }

            // --- Draw Reference Layer ---
            if (referenceCanvasId !== null && referenceCanvasId !== currentCanvasId) {
                const refResult = getCanvasById(referenceCanvasId);
                if (refResult) {
                    const referenceCanvas = refResult.canvas;
                    ctx.strokeStyle = 'rgba(136, 136, 136, 0.5)';
                    ctx.setLineDash([5 / scale, 5 / scale]);
                    ctx.lineWidth = 1 / scale;

                    referenceCanvas.shapes.forEach(shape => {
                        drawShape(shape, ctx, true);
                    });
                    ctx.setLineDash([]);
                }
            }

            // --- Draw Active Layer ---
            currentCanvas.shapes.forEach(shape => {
                const isSelected = selectedShape && selectedShape.id === shape.id;
                drawShape(shape, ctx, false, isSelected);
            });
            
            // --- Draw curve in progress ---
            if (activeTool === 'curve' && curvePoints.length > 0) {
                const mousePos = getMousePos({clientX: lastMouseX, clientY: lastMouseY});
                const previewPoints = [...curvePoints, mousePos];
                
                if (previewPoints.length >= 2) {
                    const curve = generateCatmullRomSpline(previewPoints);
                    const wallPolygon = createWallPolygonFromCurve(curve, currentWallThickness);

                    if (wallPolygon && wallPolygon.length > 0) {
                        ctx.fillStyle = 'rgba(136, 136, 136, 0.4)';
                        ctx.strokeStyle = 'var(--text-secondary)';
                        ctx.lineWidth = 1 / scale;
                        ctx.setLineDash([4 / scale, 4 / scale]);
                        
                        ctx.beginPath();
                        ctx.moveTo(wallPolygon[0].x, wallPolygon[0].y);
                        for(let i = 1; i < wallPolygon.length; i++) {
                            ctx.lineTo(wallPolygon[i].x, wallPolygon[i].y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }

                ctx.fillStyle = 'var(--text-secondary)';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1 / scale;
                curvePoints.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, (SNAP_POINT_RADIUS - 1) / scale, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                });
            }

            // --- Draw Snap Points ---
            currentCanvas.shapes.forEach(shape => {
                if (shape.type === 'rectangle' || !shape.type) {
                    const snapPoints = getSnapPoints(shape);
                    snapPoints.forEach(p => {
                        const isHovered = hoveredSnapPoint && hoveredSnapPoint.x === p.x && hoveredSnapPoint.y === p.y;
                        
                        if (isHovered) {
                            ctx.fillStyle = 'var(--success-color)';
                            ctx.strokeStyle = '#000';
                            ctx.lineWidth = 1 / scale;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, (SNAP_POINT_RADIUS + 2) / scale, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.stroke();
                        } else {
                            ctx.fillStyle = 'rgba(136, 136, 136, 0.6)';
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 1.5 / scale;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, SNAP_POINT_RADIUS / scale, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.stroke();
                        }
                    });
                }
            });
            ctx.restore();
        }

        function drawShape(shape, context, isReference, isSelected) {
            let wallPoints;
            if (shape.type === 'curve') {
                const curvePoints = generateCatmullRomSpline(shape.points);
                wallPoints = createWallPolygonFromCurve(curvePoints, shape.thickness);
            } else if (shape.type === 'circle') {
                context.beginPath();
                context.arc(shape.center.x, shape.center.y, shape.radius, 0, Math.PI * 2);
            } else { // Rectangle and legacy
                wallPoints = shape.points;
            }

            if (wallPoints) {
                if(wallPoints.length === 0) return;
                context.beginPath();
                context.moveTo(wallPoints[0].x, wallPoints[0].y);
                for(let i = 1; i < wallPoints.length; i++) {
                    context.lineTo(wallPoints[i].x, wallPoints[i].y);
                }
                context.closePath();
            }

            if(isReference) {
                context.stroke();
            } else {
                context.strokeStyle = isSelected ? 'var(--accent-hover)' : 'var(--accent-color)';
                context.fillStyle = isSelected ? 'rgba(59, 130, 246, 0.3)' : 'rgba(13, 110, 253, 0.2)';
                context.lineWidth = isSelected ? 2 / scale : 1.5 / scale;
                context.fill();
                context.stroke();
            }
        }

        // --- MOUSE/TOOL LOGIC ---
        let startPoint = { x: 0, y: 0 };
        let lastMouseX = 0, lastMouseY = 0;

        function getMousePos(evt, useScale = true) {
            const rect = canvas.getBoundingClientRect();
            const currentScale = useScale ? scale : 1;
            return {
                x: (evt.clientX - rect.left - canvasOffset.x) / currentScale,
                y: (evt.clientY - rect.top - canvasOffset.y) / currentScale
            };
        }

        function onMouseDown(e) {
            if (e.button === 2) { // Pan
                isPannning = true;
                panStart.x = e.clientX;
                panStart.y = e.clientY;
                canvas.style.cursor = 'grabbing';
                return;
            }
            if (e.button !== 0) return;
            
            // Prioritize dragging from snap point
            if (hoveredSnapPoint) {
                isDraggingFromSnap = true;
                const currentCanvas = getCanvasById(currentCanvasId)?.canvas;
                dragStartState = {
                    startPos: { ...hoveredSnapPoint },
                    parentShape: currentCanvas.shapes.find(s => s.id === hoveredSnapPoint.parentId)
                };
                hoveredSnapPoint = null;
                return;
            }

            if (activeTool === 'curve') {
                const pos = getMousePos(e);
                curvePoints.push(pos);
                isDrawing = true;
                drawAllShapes();
                return;
            }

            if (activeTool === 'rectangle' || activeTool === 'circle') {
                isDrawing = true;
                startPoint = getMousePos(e);
            }
        }
        
        function onDoubleClick(e) {
            const mousePos = getMousePos(e);
            const currentCanvas = getCanvasById(currentCanvasId)?.canvas;
            if (!currentCanvas) return;
            const clickedShape = findClickedShape(mousePos, currentCanvas.shapes);
            
            if (clickedShape) {
                selectedShape = clickedShape;
                openWallEditor(clickedShape);
            } else {
                selectedShape = null;
                closeWallEditor();
            }
            drawAllShapes();
        }

        function findClickedShape(position, shapes) {
            return shapes.find(shape => {
                if (shape.type === 'circle') {
                    const dx = position.x - shape.center.x;
                    const dy = position.y - shape.center.y;
                    return (dx * dx + dy * dy) < (shape.radius * shape.radius);
                }

                let wallPoints;
                if(shape.type === 'curve') {
                    const curvePoints = generateCatmullRomSpline(shape.points);
                    wallPoints = createWallPolygonFromCurve(curvePoints, shape.thickness);
                } else {
                    wallPoints = shape.points;
                }
                if(!wallPoints) return false;
                
                let inside = false;
                for (let i = 0, j = wallPoints.length - 1; i < wallPoints.length; j = i++) {
                    const xi = wallPoints[i].x, yi = wallPoints[i].y;
                    const xj = wallPoints[j].x, yj = wallPoints[j].y;
                    const intersect = ((yi > position.y) !== (yj > position.y))
                        && (position.x < (xj - xi) * (position.y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            });
        }


        function onCanvasWheel(e) {
            e.preventDefault();
            const zoomIntensity = 0.1;
            const wheel = e.deltaY < 0 ? 1 : -1;
            const zoom = Math.exp(wheel * zoomIntensity);
            
            const mousePos = getMousePos(e, false);
            const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * zoom));
            
            canvasOffset.x = mousePos.x - (mousePos.x - canvasOffset.x) * (newScale / scale);
            canvasOffset.y = mousePos.y - (mousePos.y - canvasOffset.y) * (newScale / scale);
            
            scale = newScale;
            drawAllShapes();
        }

        function onMouseMove(e) {
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            if (isPannning) {
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;
                canvasOffset.x += dx;
                canvasOffset.y += dy;
                panStart.x = e.clientX;
                panStart.y = e.clientY;
                drawAllShapes();
                return;
            }

            if (activeTool === 'curve' && isDrawing) {
                drawAllShapes();
                return;
            }

            let currentPos = getMousePos(e);
            activeSnapTarget = null;
            
            // Hover detection for snap points
            if (!isDraggingFromSnap) {
                let foundHover = null;
                const currentCanvas = getCanvasById(currentCanvasId)?.canvas;
                if (currentCanvas) {
                    currentCanvas.shapes.forEach(shape => {
                        if (shape.type === 'rectangle' || !shape.type) {
                            const snapPoints = getSnapPoints(shape);
                            for (const point of snapPoints) {
                                const dx = currentPos.x - point.x;
                                const dy = currentPos.y - point.y;
                                if (dx * dx + dy * dy < (SNAP_POINT_RADIUS / scale) ** 2) {
                                    foundHover = point;
                                    break;
                                }
                            }
                        }
                        if(foundHover) return;
                    });
                }
                if (hoveredSnapPoint !== foundHover) {
                    hoveredSnapPoint = foundHover;
                    canvas.style.cursor = foundHover ? 'pointer' : 'crosshair';
                    drawAllShapes();
                }
            }
            
            // Drawing preview for dragging from snap point
            if (isDraggingFromSnap) {
                if (isShiftPressed) {
                    const { startPos } = dragStartState;
                    const vec = { x: currentPos.x - startPos.x, y: currentPos.y - startPos.y };
                    const len = Math.sqrt(vec.x * vec.x + vec.y * vec.y);

                    if (len > 0) {
                        const angleRad = Math.atan2(vec.y, vec.x);
                        const angleDeg = angleRad * (180 / Math.PI);
                        const snapIncrement = 10;
                        const snappedAngleDeg = Math.round(angleDeg / snapIncrement) * snapIncrement;
                        const snappedAngleRad = snappedAngleDeg * (Math.PI / 180);

                        currentPos.x = startPos.x + len * Math.cos(snappedAngleRad);
                        currentPos.y = startPos.y + len * Math.sin(snappedAngleRad);
                    }
                }

                let closestSnap = null;
                let minSnapDist = (SNAP_DISTANCE / scale)**2;
                getAllCanvases().forEach(c => {
                    c.shapes.forEach(shape => {
                        if (c.id === currentCanvasId && shape.id === dragStartState.parentShape.id) return;
                        getSnapPoints(shape).forEach(p => {
                            const distSq = (p.x - currentPos.x)**2 + (p.y - currentPos.y)**2;
                            if (distSq < minSnapDist) {
                                minSnapDist = distSq;
                                closestSnap = p;
                            }
                        });
                    });
                });
                if (closestSnap) {
                    currentPos.x = closestSnap.x;
                    currentPos.y = closestSnap.y;
                    activeSnapTarget = closestSnap;
                }

                drawAllShapes();
                ctx.save();
                ctx.translate(canvasOffset.x, canvasOffset.y);
                ctx.scale(scale, scale);
                ctx.fillStyle = 'rgba(13, 110, 253, 0.3)';
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
                ctx.lineWidth = 1 / scale;

                const { startPos, parentShape } = dragStartState;
                const thickness = parentShape.thickness || Math.min(parentShape.width, parentShape.height);
                
                const vec = { x: currentPos.x - startPos.x, y: currentPos.y - startPos.y };
                const len = Math.sqrt(vec.x * vec.x + vec.y * vec.y);
                if (len > 0) {
                    const perpVec = { x: -vec.y / len, y: vec.x / len };
                    const p1 = { x: startPos.x - perpVec.x * thickness / 2, y: startPos.y - perpVec.y * thickness / 2 };
                    const p2 = { x: startPos.x + perpVec.x * thickness / 2, y: startPos.y + perpVec.y * thickness / 2 };
                    const p3 = { x: currentPos.x + perpVec.x * thickness / 2, y: currentPos.y + perpVec.y * thickness / 2 };
                    const p4 = { x: currentPos.x - perpVec.x * thickness / 2, y: currentPos.y - perpVec.y * thickness / 2 };
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.lineTo(p3.x, p3.y);
                    ctx.lineTo(p4.x, p4.y);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
                return;
            }
            
            if (isDrawing && (activeTool === 'rectangle' || activeTool === 'circle')) {
                 drawAllShapes();
                 ctx.save();
                 ctx.translate(canvasOffset.x, canvasOffset.y);
                 ctx.scale(scale, scale);
                 ctx.fillStyle = 'rgba(13, 110, 253, 0.3)';
                 ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
                 ctx.lineWidth = 1 / scale;
                 ctx.beginPath();
                 if (activeTool === 'rectangle') {
                      ctx.rect(startPoint.x, startPoint.y, currentPos.x - startPoint.x, currentPos.y - startPoint.y);
                 } else { // Circle
                      const radius = Math.sqrt((currentPos.x - startPoint.x)**2 + (currentPos.y - startPoint.y)**2);
                      ctx.arc(startPoint.x, startPoint.y, radius, 0, Math.PI * 2);
                 }
                 ctx.fill();
                 ctx.stroke();
                 ctx.restore();
            }
        }

        function onMouseUp(e) {
            if (isPannning) {
                isPannning = false;
                canvas.style.cursor = hoveredSnapPoint ? 'pointer' : 'crosshair';
                return;
            }
            
            let endPoint = getMousePos(e);
            const currentCanvas = getCanvasById(currentCanvasId)?.canvas;
            if (!currentCanvas) return;

            if (isDraggingFromSnap) {
                if (activeSnapTarget) {
                    endPoint.x = activeSnapTarget.x;
                    endPoint.y = activeSnapTarget.y;
                }
                const { startPos, parentShape } = dragStartState;
                const thickness = parentShape.thickness || Math.min(parentShape.width, parentShape.height);
                const vec = { x: endPoint.x - startPos.x, y: endPoint.y - startPos.y };
                const len = Math.sqrt(vec.x * vec.x + vec.y * vec.y);

                if (len > 2) {
                    const perpVec = { x: -vec.y / len, y: vec.x / len };
                    const p1 = { x: startPos.x - perpVec.x * thickness / 2, y: startPos.y - perpVec.y * thickness / 2 };
                    const p2 = { x: startPos.x + perpVec.x * thickness / 2, y: startPos.y + perpVec.y * thickness / 2 };
                    const p3 = { x: endPoint.x + perpVec.x * thickness / 2, y: endPoint.y + perpVec.y * thickness / 2 };
                    const p4 = { x: endPoint.x - perpVec.x * thickness / 2, y: endPoint.y - perpVec.y * thickness / 2 };
                    
                    currentCanvas.shapes.push({
                        id: Date.now(),
                        type: 'rectangle',
                        points: [p1, p2, p3, p4],
                        wallHeight: parentShape.wallHeight,
                        thickness: thickness,
                        width: len,
                        height: thickness
                    });
                }
            } else if (isDrawing) {
                if (activeTool === 'rectangle') {
                    const rect = {
                        x: Math.min(startPoint.x, endPoint.x),
                        y: Math.min(startPoint.y, endPoint.y),
                        w: Math.abs(startPoint.x - endPoint.x),
                        h: Math.abs(startPoint.y - endPoint.y)
                    };
                    if (rect.w > 2 && rect.h > 2) {
                        currentCanvas.shapes.push({
                            id: Date.now(),
                            type: 'rectangle',
                            points: [
                                { x: rect.x, y: rect.y },
                                { x: rect.x + rect.w, y: rect.y },
                                { x: rect.x + rect.w, y: rect.y + rect.h },
                                { x: rect.x, y: rect.y + rect.h }
                            ],
                            wallHeight: 50,
                            thickness: 10,
                            width: rect.w,
                            height: rect.h
                        });
                    }
                } else if (activeTool === 'circle') {
                    const radius = Math.sqrt((endPoint.x - startPoint.x)**2 + (endPoint.y - startPoint.y)**2);
                    if (radius > 1) {
                        currentCanvas.shapes.push({
                            id: Date.now(),
                            type: 'circle',
                            center: startPoint,
                            radius: radius,
                            height: 50,
                            segments: 32, // Default segments
                        });
                    }
                }
            }
            
            isDrawing = false;
            isDraggingFromSnap = false;
            activeSnapTarget = null;
            drawAllShapes();
            update3DScene();
            updateJsonEditor();
        }

        function onMouseLeave() {
            if (isDrawing || isPannning || isDraggingFromSnap) {
                isDrawing = false;
                isPannning = false;
                isDraggingFromSnap = false;
                dragStartState = {};
                drawAllShapes();
                update3DScene();
            }
        }
        
        function openWallEditor(shape) {
            wallEditor.style.display = 'flex';
            
            if (shape.type === 'circle') {
                editorTitle.textContent = "Edit Pillar";
                groupWallHeight.style.display = 'block';
                groupWallThickness.style.display = 'none';
                groupPillarRadius.style.display = 'block';
                groupPillarSegments.style.display = 'block';
                
                wallHeightInput.value = shape.height;
                pillarRadiusInput.value = shape.radius;
                pillarSegmentsInput.value = shape.segments;

            } else { // Rectangle or Curve
                editorTitle.textContent = "Edit Wall";
                groupWallHeight.style.display = 'block';
                groupWallThickness.style.display = 'block';
                groupPillarRadius.style.display = 'none';
                groupPillarSegments.style.display = 'none';

                wallHeightInput.value = shape.wallHeight;
                wallThicknessInput.value = shape.thickness || 10;
            }
        }

        function closeWallEditor() {
            wallEditor.style.display = 'none';
            if (selectedShape) {
                selectedShape = null;
                drawAllShapes();
            }
        }
        
        function createWallPolygonFromCurve(points, thickness) {
            if (points.length < 2) return [];

            const wallPoints = [];
            const halfThick = thickness / 2;

            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p0 = points[i - 1] || p1;
                const p2 = points[i + 1] || p1;

                const v1 = { x: p1.x - p0.x, y: p1.y - p0.y };
                const v2 = { x: p2.x - p1.x, y: p2.y - p1.y };

                const n1 = { x: -v1.y, y: v1.x };
                const n2 = { x: -v2.y, y: v2.x };
                
                const l1 = Math.sqrt(n1.x * n1.x + n1.y * n1.y) || 1;
                n1.x /= l1; n1.y /= l1;

                const l2 = Math.sqrt(n2.x * n2.x + n2.y * n2.y) || 1;
                n2.x /= l2; n2.y /= l2;

                let bisector = { x: n1.x + n2.x, y: n1.y + n2.y };
                const bl = Math.sqrt(bisector.x * bisector.x + bisector.y * bisector.y) || 1;
                bisector.x /= bl; bisector.y /= bl;

                const dot = n1.x * bisector.x + n1.y * bisector.y;
                
                if (Math.abs(dot) < 0.0001) {
                    wallPoints.push({ x: p1.x + n1.x * halfThick, y: p1.y + n1.y * halfThick });
                } else {
                    const miterLength = halfThick / dot;
                    wallPoints.push({ x: p1.x + bisector.x * miterLength, y: p1.y + bisector.y * miterLength });
                }
            }
            
            for (let i = points.length - 1; i >= 0; i--) {
                const p1 = points[i];
                const p0 = points[i - 1] || p1;
                const p2 = points[i + 1] || p1;

                const v1 = { x: p1.x - p0.x, y: p1.y - p0.y };
                const v2 = { x: p2.x - p1.x, y: p2.y - p1.y };

                const n1 = { x: -v1.y, y: v1.x };
                const n2 = { x: -v2.y, y: v2.x };
                
                const l1 = Math.sqrt(n1.x * n1.x + n1.y * n1.y) || 1;
                n1.x /= l1; n1.y /= l1;

                const l2 = Math.sqrt(n2.x * n2.x + n2.y * n2.y) || 1;
                n2.x /= l2; n2.y /= l2;

                let bisector = { x: n1.x + n2.x, y: n1.y + n2.y };
                const bl = Math.sqrt(bisector.x * bisector.x + bisector.y * bisector.y) || 1;
                bisector.x /= bl; bisector.y /= bl;

                const dot = n1.x * bisector.x + n1.y * bisector.y;
                
                if (Math.abs(dot) < 0.0001) {
                    wallPoints.push({ x: p1.x - n1.x * halfThick, y: p1.y - n1.y * halfThick });
                } else {
                    const miterLength = halfThick / dot;
                    wallPoints.push({ x: p1.x - bisector.x * miterLength, y: p1.y - bisector.y * miterLength });
                }
            }

            return wallPoints;
        }

        function generateCatmullRomSpline(points, segments = 20) {
            if (points.length < 2) return points;

            const curve = new THREE.CatmullRomCurve3(
                points.map(p => new THREE.Vector3(p.x, p.y, 0))
            );
            return curve.getPoints(points.length * segments).map(v => ({x: v.x, y: v.y}));
        }


        function update3DScene() {
            if (transformControls.object) {
                transformControls.detach();
            }

            while (wallGroup.children.length > 0) {
                wallGroup.remove(wallGroup.children[0]);
            }

            const defaultMaterial = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.7, metalness: 0.0 });
            const offsetX = -canvas.width / 2;
            const offsetZ = -canvas.height / 2;

            layerGroups.forEach(group => {
                group.layers.forEach(c => {
                    if (!c.isVisible) return;

                    c.shapes.forEach(shape => {
                        let geometry;
                        let mesh;
                        
                        const material = shape.material 
                            ? new THREE.MeshStandardMaterial(shape.material)
                            : defaultMaterial.clone();

                        if (shape.type === 'circle') {
                            const finalHeight = Math.max(1, (shape.height || 50) - globalHeightAdjustment);
                            geometry = new THREE.CylinderGeometry(shape.radius, shape.radius, finalHeight, shape.segments);
                            mesh = new THREE.Mesh(geometry, material);
                            mesh.position.set(shape.center.x + offsetX, group.height + finalHeight / 2, shape.center.y + offsetZ);
                        } else {
                            let wallShapePoints = [];
                            if (shape.type === 'curve') {
                                const curvePoints = generateCatmullRomSpline(shape.points);
                                wallShapePoints = createWallPolygonFromCurve(curvePoints, shape.thickness);
                            } else {
                                wallShapePoints = shape.points;
                            }

                            if (wallShapePoints.length === 0) return;

                            const wallShape = new THREE.Shape();
                            wallShape.moveTo(wallShapePoints[0].x, wallShapePoints[0].y);
                            for (let i = 1; i < wallShapePoints.length; i++) {
                                wallShape.lineTo(wallShapePoints[i].x, wallShapePoints[i].y);
                            }
                            
                            const finalHeight = Math.max(1, (shape.wallHeight || 50) - globalHeightAdjustment);
                            const extrudeSettings = { steps: 1, depth: finalHeight, bevelEnabled: false };
                            geometry = new THREE.ExtrudeGeometry(wallShape, extrudeSettings);
                            
                            geometry.rotateX(-Math.PI / 2);
                            geometry.translate(offsetX, group.height, offsetZ);

                            mesh = new THREE.Mesh(geometry, material);
                        }
                        
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.userData = { canvasId: c.id, shapeId: shape.id };
                        wallGroup.add(mesh);
                    });
                });
            });
            wallGroup.scale.set(globalModelScale, globalModelScale, globalModelScale);
        }

        // --- UI AND EVENT LISTENERS ---
        function renderFileTree() {
            const referenceOnSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-image-fill" viewBox="0 0 16 16"><path d="M.002 3a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-12a2 2 0 0 1-2-2V3zm1 9l2.646-2.354a.5.5 0 0 1 .63-.062l2.66 1.773 3.71-3.71a.5.5 0 0 1 .577-.094L15.002 9.5V3a1 1 0 0 0-1-1h-12a1 1 0 0 0-1 1v9z"/><path d="M10.5 8.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0z"/></svg>`;
            const referenceOffSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-image" viewBox="0 0 16 16"><path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/><path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/></svg>`;
            const circleFilledSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-circle-fill" viewBox="0 0 16 16"><circle cx="8" cy="8" r="8"/></svg>`;
            const circleOutlineSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-circle" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/></svg>`;
            const deleteSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg>`;

            canvasList.innerHTML = '';
            
            const sortedGroups = [...layerGroups].sort((a, b) => a.height - b.height);

            sortedGroups.forEach(group => {
                const groupContainer = document.createElement('div');
                groupContainer.className = 'layer-group';

                const groupHeader = document.createElement('div');
                groupHeader.className = 'layer-group-header';
                groupHeader.textContent = `Level at ${group.height.toFixed(0)}`;
                groupContainer.appendChild(groupHeader);

                const innerList = document.createElement('ul');
                group.layers.forEach(c => {
                    const li = document.createElement('li');
                    li.dataset.id = c.id;

                    const referenceIcon = document.createElement('div');
                    referenceIcon.classList.add('layer-icon');
                    const isReference = referenceCanvasId === c.id;
                    referenceIcon.innerHTML = isReference ? referenceOnSVG : referenceOffSVG;
                    referenceIcon.title = "Set as 2D Reference";

                    referenceIcon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (c.id === currentCanvasId) return;
                        referenceCanvasId = isReference ? null : c.id;
                        renderFileTree();
                        drawAllShapes();
                    });

                    const visibilityIcon = document.createElement('div');
                    visibilityIcon.classList.add('layer-icon');
                    visibilityIcon.innerHTML = c.isVisible ? circleFilledSVG : circleOutlineSVG;
                    visibilityIcon.title = "Toggle 3D Visibility";

                    visibilityIcon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        c.isVisible = !c.isVisible;
                        update3DScene();
                        renderFileTree();
                    });

                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = c.name;
                    nameSpan.classList.add('canvas-name');

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-layer-btn';
                    deleteBtn.innerHTML = deleteSVG;
                    deleteBtn.title = "Delete Layer";
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        deleteLayer(c.id);
                    });

                    li.appendChild(referenceIcon);
                    li.appendChild(visibilityIcon);
                    li.appendChild(nameSpan);
                    li.appendChild(deleteBtn);

                    if (c.id === currentCanvasId) li.classList.add('active');
                    
                    li.addEventListener('click', () => {
                        if (currentCanvasId === c.id) return;
                        currentCanvasId = c.id;
                        if (referenceCanvasId === currentCanvasId) referenceCanvasId = null;
                        closeWallEditor();
                        renderFileTree();
                        drawAllShapes();
                    });
                    innerList.appendChild(li);
                });
                groupContainer.appendChild(innerList);
                canvasList.appendChild(groupContainer);
            });
        }

        function deleteLayer(layerId) {
            let groupIndexToDelete = -1;
            let layerIndexToDelete = -1;

            layerGroups.forEach((group, gIndex) => {
                const lIndex = group.layers.findIndex(l => l.id === layerId);
                if (lIndex !== -1) {
                    groupIndexToDelete = gIndex;
                    layerIndexToDelete = lIndex;
                }
            });

            if (groupIndexToDelete !== -1 && layerIndexToDelete !== -1) {
                layerGroups[groupIndexToDelete].layers.splice(layerIndexToDelete, 1);
                if (layerGroups[groupIndexToDelete].layers.length === 0 && layerGroups.length > 1) {
                    layerGroups.splice(groupIndexToDelete, 1);
                }
            }

            if (currentCanvasId === layerId) {
                const allCanvases = getAllCanvases();
                currentCanvasId = allCanvases.length > 0 ? allCanvases[0].id : -1;
            }
            if (referenceCanvasId === layerId) {
                referenceCanvasId = null;
            }

            renderFileTree();
            drawAllShapes();
            update3DScene();
            updateJsonEditor();
        }

        function on3DViewRightClick(event) {
            event.preventDefault();
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            const rect = renderer.domElement.getBoundingClientRect();

            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(wallGroup.children, true);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const clickedObject = intersect.object;
                const { canvasId, shapeId } = clickedObject.userData;
                
                const result = getCanvasById(canvasId);
                if (result) {
                    const { canvas, group } = result;
                    const shape = canvas.shapes.find(s => s.id === shapeId);
                    if (shape) {
                        const shapeHeight = shape.type === 'circle' ? shape.height : shape.wallHeight;
                        const topSurfaceHeight = group.height + shapeHeight;
                        newCanvasData.height = topSurfaceHeight;
                        createCanvasModal.style.display = 'flex';
                        newCanvasNameInput.focus();
                    }
                }
            }
        }

        function on3DViewDblClick(event) {
           const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            const rect = renderer.domElement.getBoundingClientRect();

            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([...wallGroup.children, scene.children.find(c => c.userData.isGround)], true);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                if (!clickedObject.userData.isGround) {
                    selected3DObject = clickedObject;
                    transformControls.attach(selected3DObject);
                } else {
                    if (selected3DObject) {
                        transformControls.detach();
                        selected3DObject = null;
                    }
                }
            } else {
                if (selected3DObject) {
                    transformControls.detach();
                    selected3DObject = null;
                }
            }
        }

        function handleResize() {
            resizeCanvas();
            const container3D = document.getElementById('renderer-container');
            camera.aspect = container3D.clientWidth / container3D.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container3D.clientWidth, container3D.clientHeight);
        }
        
        window.addEventListener('resize', handleResize);

        window.addEventListener('keydown', (e) => { 
            if (e.key === 'Shift') isShiftPressed = true; 
            if (e.key === 'Enter' && activeTool === 'curve' && curvePoints.length > 1) {
                const currentCanvas = getCanvasById(currentCanvasId)?.canvas;
                if (!currentCanvas) return;
                currentCanvas.shapes.push({
                    id: Date.now(),
                    type: 'curve',
                    points: curvePoints,
                    wallHeight: 50,
                    thickness: currentWallThickness,
                });
                curvePoints = [];
                isDrawing = false;
                drawAllShapes();
                update3DScene();
                updateJsonEditor();
            }
             if (e.key === 'Escape') {
                curvePoints = [];
                isDrawing = false;
                closeWallEditor();
                drawAllShapes();
            }
        });
        window.addEventListener('keyup', (e) => { if (e.key === 'Shift') isShiftPressed = false; });

        document.getElementById('tool-clear').addEventListener('click', () => {
            const currentCanvas = getCanvasById(currentCanvasId)?.canvas;
            if (currentCanvas) {
                currentCanvas.shapes = [];
                closeWallEditor();
                drawAllShapes();
                update3DScene();
                updateJsonEditor();
            }
        });

        document.getElementById('editor-tool-delete').addEventListener('click', () => {
            if (!selectedShape) return;
            const result = getCanvasById(currentCanvasId);
            if (result && result.canvas) {
                const index = result.canvas.shapes.findIndex(s => s.id === selectedShape.id);
                if (index > -1) {
                    result.canvas.shapes.splice(index, 1);
                }
            }
            closeWallEditor();
            drawAllShapes();
            update3DScene();
            updateJsonEditor();
        });

        wallHeightInput.addEventListener('change', () => {
            if (!selectedShape) return;
            if (selectedShape.type === 'circle') {
                selectedShape.height = parseFloat(wallHeightInput.value) || 50;
            } else {
                selectedShape.wallHeight = parseFloat(wallHeightInput.value) || 50;
            }
            update3DScene();
            updateJsonEditor();
        });
        
        wallThicknessInput.addEventListener('change', () => {
            if (selectedShape && (selectedShape.type === 'rectangle' || selectedShape.type === 'curve')) {
                selectedShape.thickness = parseFloat(wallThicknessInput.value) || 10;
                drawAllShapes();
                update3DScene();
                updateJsonEditor();
            }
        });
        
        pillarRadiusInput.addEventListener('change', () => {
            if (selectedShape && selectedShape.type === 'circle') {
                selectedShape.radius = parseFloat(pillarRadiusInput.value) || 20;
                drawAllShapes();
                update3DScene();
                updateJsonEditor();
            }
        });

        pillarSegmentsInput.addEventListener('change', () => {
            if (selectedShape && selectedShape.type === 'circle') {
                selectedShape.segments = parseInt(pillarSegmentsInput.value, 10) || 32;
                if (selectedShape.segments < 3) selectedShape.segments = 3;
                drawAllShapes();
                update3DScene();
                updateJsonEditor();
            }
        });

        document.getElementById('add-layer-btn').addEventListener('click', () => {
            let maxZ = 0;
            layerGroups.forEach(group => {
                group.layers.forEach(c => {
                    c.shapes.forEach(s => {
                        const shapeHeight = s.type === 'circle' ? s.height : s.wallHeight;
                        const top = group.height + (shapeHeight || 0);
                        if (top > maxZ) {
                            maxZ = top;
                        }
                    });
                });
            });
            
            newCanvasData.height = maxZ > 0 ? maxZ : (getAllCanvases().length * 50);
            createCanvasModal.style.display = 'flex';
            newCanvasNameInput.focus();
        });


        document.getElementById('cancel-create-canvas').addEventListener('click', () => {
            createCanvasModal.style.display = 'none';
        });

        document.getElementById('confirm-create-canvas').addEventListener('click', () => {
            const name = newCanvasNameInput.value.trim();
            if (name) {
                const newCanvas = {
                    id: Date.now(),
                    name: name,
                    shapes: [],
                    isVisible: true
                };
                const height = newCanvasData.height || 0;
                
                let group = layerGroups.find(g => g.height === height);
                if (group) {
                    group.layers.push(newCanvas);
                } else {
                    layerGroups.push({
                        height: height,
                        layers: [newCanvas]
                    });
                }

                currentCanvasId = newCanvas.id;
                renderFileTree();
                drawAllShapes();
                updateJsonEditor();
                createCanvasModal.style.display = 'none';
                newCanvasNameInput.value = '';
            }
        });
        
        // --- Tool selection ---
        const toolButtons = {
            rectangle: document.getElementById('tool-rectangle'),
            curve: document.getElementById('tool-curve'),
            circle: document.getElementById('tool-circle'),
        };
        
        function setTool(toolName) {
            activeTool = toolName;
            
            if(toolName !== 'curve' && curvePoints.length > 0) {
                curvePoints = [];
                isDrawing = false;
                drawAllShapes();
            }

            Object.values(toolButtons).forEach(button => button.classList.remove('active'));
            if(toolButtons[toolName]) {
                toolButtons[toolName].classList.add('active');
            }
            
            curveOptions.style.display = toolName === 'curve' ? 'flex' : 'none';
            canvas.style.cursor = 'crosshair';
        }
        
        toolButtons.rectangle.addEventListener('click', () => setTool('rectangle'));
        toolButtons.curve.addEventListener('click', () => setTool('curve'));
        toolButtons.circle.addEventListener('click', () => setTool('circle'));
        
        curveThicknessInput.addEventListener('change', (e) => {
            currentWallThickness = parseFloat(e.target.value) || 10;
        });

        // --- Material Editor Listeners ---
        materialColorInput.addEventListener('input', (e) => {
            if(selected3DObject) {
                selected3DObject.material.color.set(e.target.value);
                const { canvasId, shapeId } = selected3DObject.userData;
                const result = getCanvasById(canvasId);
                if (!result) return;
                const shape = result.canvas.shapes.find(s => s.id === shapeId);
                if (!shape.material) shape.material = {};
                shape.material.color = e.target.value;
                updateJsonEditor();
            }
        });
        materialRoughnessInput.addEventListener('input', (e) => {
            if(selected3DObject) {
                const value = parseFloat(e.target.value);
                selected3DObject.material.roughness = value;
                const { canvasId, shapeId } = selected3DObject.userData;
                const result = getCanvasById(canvasId);
                if (!result) return;
                const shape = result.canvas.shapes.find(s => s.id === shapeId);
                if (!shape.material) shape.material = {};
                shape.material.roughness = value;
                updateJsonEditor();
            }
        });
        materialMetalnessInput.addEventListener('input', (e) => {
            if(selected3DObject) {
                const value = parseFloat(e.target.value);
                selected3DObject.material.metalness = value;
                 const { canvasId, shapeId } = selected3DObject.userData;
                const result = getCanvasById(canvasId);
                if (!result) return;
                const shape = result.canvas.shapes.find(s => s.id === shapeId);
                if (!shape.material) shape.material = {};
                shape.material.metalness = value;
                updateJsonEditor();
            }
        });
        

        // --- Resizer Logic ---
        function initResizers() {
            // Vertical Resizer
            let isResizingVertical = false;
            resizer.addEventListener('mousedown', function(e) {
                isResizingVertical = true;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('mousemove', function(e) {
                if (!isResizingVertical) return;
                
                const editorArea = document.getElementById('editor-area');
                const containerRect = editorArea.getBoundingClientRect();
                const leftPanelWidth = e.clientX - containerRect.left;
                const rightPanelWidth = containerRect.width - leftPanelWidth - resizer.offsetWidth;
                
                if (leftPanelWidth > 200 && rightPanelWidth > 200) {
                    panel2dContainer.style.flex = `0 0 ${leftPanelWidth}px`;
                    panel3d.style.flex = `1 1 ${rightPanelWidth}px`;
                    handleResize();
                }
            });

            document.addEventListener('mouseup', function(e) {
                isResizingVertical = false;
                document.body.style.cursor = 'default';
                document.body.style.userSelect = 'auto';
            });
        }
        
        // --- Sidebar Logic ---
        jsonToolBtn.addEventListener('click', () => {
            const isDisplayed = jsonSidebar.style.display === 'flex';
            jsonSidebar.style.display = isDisplayed ? 'none' : 'flex';
            jsonToolBtn.classList.toggle('active', !isDisplayed);
            // Allow layout to reflow before resizing canvases
            setTimeout(handleResize, 10);
        });
        
        layersToolBtn.addEventListener('click', () => {
            const isDisplayed = layersSidebar.style.display === 'flex';
            layersSidebar.style.display = isDisplayed ? 'none' : 'flex';
            layersToolBtn.classList.toggle('active', !isDisplayed);
            // Allow layout to reflow before resizing canvases
            setTimeout(handleResize, 10);
        });

        function updateJsonEditor() {
            jsonEditor.value = JSON.stringify(layerGroups, null, 2);
        }

        jsonEditor.addEventListener('blur', () => {
            try {
                const newData = JSON.parse(jsonEditor.value);
                layerGroups = newData;
                // find the current active canvas id from the new data
                const activeCanvas = getCanvasById(currentCanvasId);
                if(!activeCanvas) {
                    currentCanvasId = layerGroups.length > 0 && layerGroups[0].layers.length > 0 ? layerGroups[0].layers[0].id : 0;
                }
                
                renderFileTree();
                drawAllShapes();
                update3DScene();
                jsonEditor.style.borderColor = 'transparent';
            } catch (e) {
                console.error("Invalid JSON:", e);
                jsonEditor.style.borderColor = 'var(--danger-color)';
            }
        });

        // --- Floorplan Import Logic ---
        importFloorplanBtn.addEventListener('click', () => {
            floorplanUpload.click();
        });

        toggleReferenceBtn.addEventListener('click', () => {
            showReferenceImage = !showReferenceImage;
            drawAllShapes();
        });

        floorplanUpload.addEventListener('change', handleFloorplanUpload);

        async function handleFloorplanUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const result = getCanvasById(currentCanvasId);
                if (!result) return;
                const currentCanvas = result.canvas;

                const image = new Image();
                image.onload = () => {
                    currentCanvas.referenceImage = image;
                    toggleReferenceBtn.style.display = 'block';
                    generateFloorplanBtn.style.display = 'block';
                    uploadedFloorplan.data = e.target.result;
                    uploadedFloorplan.type = file.type;
                    drawAllShapes();
                };
                image.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        generateFloorplanBtn.addEventListener('click', () => {
            if (uploadedFloorplan.data && uploadedFloorplan.type) {
                generateFloorplanFromImage(uploadedFloorplan.data, uploadedFloorplan.type);
            }
        });

        async function generateFloorplanFromImage(base64ImageData, mimeType) {
            loadingIndicator.style.display = 'block';
            generateFloorplanBtn.style.display = 'none';
            const base64Data = base64ImageData.split(',')[1];
            
            const prompt = `
                You are an expert architectural CAD technician. Your task is to analyze the provided floorplan image and convert it into a structured JSON format that matches the provided schema. 
                - Identify all structural walls. Walls are typically represented by thick, solid parallel lines.
                - For each wall, determine the precise coordinates of its four corners. The origin (0,0) is the top-left corner of the image.
                - Represent each wall as a JSON object with a 'type' of 'rectangle'.
                - The 'points' array must contain exactly four {x, y} coordinate objects, representing the corners of the wall in order.
                - Also, identify any doors. Represent doors as simple 'rectangle' objects as well, approximating their position and size.
                - The final output must be a single valid JSON object that conforms to the schema. Do not include any explanatory text or markdown formatting.
            `;
            
            if (!mimeType || !mimeType.startsWith('image/')) {
                console.error('Invalid or missing MIME type for floorplan generation:', mimeType);
                loadingIndicator.style.display = 'none';
                return;
            }

            try {
                const payload = {
                    contents: [
                        {
                            role: "user",
                            parts: [
                                { text: prompt },
                                {
                                    inlineData: {
                                        mimeType: mimeType,
                                        data: base64Data
                                    }
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    height: { type: "NUMBER" },
                                    layers: {
                                        type: "ARRAY",
                                        items: {
                                            type: "OBJECT",
                                            properties: {
                                                id: { type: "NUMBER" },
                                                name: { type: "STRING" },
                                                shapes: {
                                                    type: "ARRAY",
                                                    items: {
                                                        type: "OBJECT",
                                                        properties: {
                                                            id: { type: "NUMBER" },
                                                            type: { type: "STRING", enum: ["rectangle"] },
                                                            points: {
                                                                type: "ARRAY",
                                                                items: {
                                                                    type: "OBJECT",
                                                                    properties: {
                                                                        x: { type: "NUMBER" },
                                                                        y: { type: "NUMBER" }
                                                                    },
                                                                    required: ["x", "y"]
                                                                }
                                                            },
                                                            wallHeight: { type: "NUMBER" },
                                                            thickness: { type: "NUMBER" }
                                                        },
                                                        required: ["id", "type", "points", "wallHeight", "thickness"]
                                                    }
                                                }
                                            },
                                            required: ["id", "name", "shapes"]
                                        }
                                    }
                                },
                                required: ["height", "layers"]
                            }
                        }
                    }
                };
                const apiKey = "" 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    parseAndApplyFloorplan(text);
                } else {
                    console.error("No content in Gemini response:", result);
                }

            } catch (error) {
                console.error("Error generating floorplan:", error);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        function parseAndApplyFloorplan(jsonString) {
            try {
                let generatedData = JSON.parse(jsonString);
                
                if (generatedData && generatedData.length > 0) {
                    // --- Auto-scaling and Centering Logic ---
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    
                    generatedData.forEach(group => {
                        group.layers.forEach(layer => {
                            layer.shapes.forEach(shape => {
                                shape.points.forEach(p => {
                                    if (p.x < minX) minX = p.x;
                                    if (p.x > maxX) maxX = p.x;
                                    if (p.y < minY) minY = p.y;
                                    if (p.y > maxY) maxY = p.y;
                                });
                            });
                        });
                    });

                    if (isFinite(minX)) {
                        const planWidth = maxX - minX;
                        const planHeight = maxY - minY;
                        
                        const canvasWidth = canvas.width;
                        const canvasHeight = canvas.height;
                        const padding = 50; // 50px padding on each side

                        const scaleX = (canvasWidth - padding * 2) / planWidth;
                        const scaleY = (canvasHeight - padding * 2) / planHeight;
                        const finalScale = Math.min(scaleX, scaleY);

                        const planCenterX = minX + planWidth / 2;
                        const planCenterY = minY + planHeight / 2;
                        
                        const canvasCenterX = canvasWidth / 2;
                        const canvasCenterY = canvasHeight / 2;

                        const offsetX = canvasCenterX - (planCenterX * finalScale);
                        const offsetY = canvasCenterY - (planCenterY * finalScale);
                        
                        // Apply the transformation
                        generatedData.forEach(group => {
                            group.layers.forEach(layer => {
                                layer.shapes.forEach(shape => {
                                    shape.points.forEach(p => {
                                        p.x = p.x * finalScale + offsetX;
                                        p.y = p.y * finalScale + offsetY;
                                    });
                                });
                            });
                        });
                    }

                    // --- Normalization Logic ---
                    generatedData[0].height = 0;
                    generatedData.forEach(group => {
                        group.layers.forEach(layer => {
                            layer.isVisible = true; // Make sure new layers are visible by default
                            layer.shapes.forEach(shape => {
                                if (shape.type === 'rectangle') {
                                    shape.wallHeight = 50;
                                }
                            });
                        });
                    });
                }

                layerGroups = generatedData;

                if (layerGroups.length > 0 && layerGroups[0].layers.length > 0) {
                    currentCanvasId = layerGroups[0].layers[0].id;
                } else {
                    layerGroups = [{ height: 0, layers: [{ id: 0, name: 'Default Layer', shapes: [], isVisible: true }] }];
                    currentCanvasId = 0;
                }

                renderFileTree();
                drawAllShapes();
                update3DScene();
                updateJsonEditor();

            } catch (error) {
                console.error("Error parsing floorplan JSON:", error, jsonString);
            }
        }
        
        // --- Global Settings Logic ---
        settingsBtn.addEventListener('click', () => {
            const isDisplayed = globalSettingsPanel.style.display === 'block';
            globalSettingsPanel.style.display = isDisplayed ? 'none' : 'block';
        });

        heightAdjustmentInput.addEventListener('input', (e) => {
            globalHeightAdjustment = parseFloat(e.target.value) || 0;
            update3DScene();
        });

        globalScaleInput.addEventListener('input', (e) => {
            globalModelScale = parseFloat(e.target.value) || 1.0;
            update3DScene();
        });

        // --- Download Logic ---
        function save(blob, filename) {
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }

        function saveString(text, filename) {
            save(new Blob([text], {type: 'text/plain'}), filename);
        }

        function saveArrayBuffer(buffer, filename) {
            save(new Blob([buffer], {type: 'application/octet-stream'}), filename);
        }

        downloadJsonBtn.addEventListener('click', () => {
            saveString(jsonEditor.value, 'floorplan.json');
        });

        downloadFbxBtn.addEventListener('click', () => {
            const exporter = new THREE.FBXExporter();
            const fbxData = exporter.parse(wallGroup);
            saveArrayBuffer(fbxData, 'model.fbx');
        });

        // --- 3D Toolbar Logic ---
        function setActiveTransformTool(tool) {
            transformControls.setMode(tool);
            translateBtn.classList.toggle('active', tool === 'translate');
            rotateBtn.classList.toggle('active', tool === 'rotate');
            scaleBtn.classList.toggle('active', tool === 'scale');
        }

        translateBtn.addEventListener('click', () => setActiveTransformTool('translate'));
        rotateBtn.addEventListener('click', () => setActiveTransformTool('rotate'));
        scaleBtn.addEventListener('click', () => setActiveTransformTool('scale'));
        
        function onTransformStart() {
            if (!transformControls.object) return;
            const object = transformControls.object;
            const { canvasId, shapeId } = object.userData;
            const shape = getCanvasById(canvasId)?.canvas.shapes.find(s => s.id === shapeId);
            preTransformState = {
                shape: JSON.parse(JSON.stringify(shape)),
                matrix: object.matrix.clone()
            };
        }

        function onTransformEnd() {
            if (!transformControls.object || !preTransformState.shape) return;

            const object = transformControls.object;
            const { canvasId, shapeId } = object.userData;
            const result = getCanvasById(canvasId);
            if (!result) return;
            const shapeToUpdate = result.canvas.shapes.find(s => s.id === shapeId);
            if (!shapeToUpdate) return;

            const transformMatrix = object.matrix.clone();
            const offsetX = -canvas.width / 2;
            const offsetZ = -canvas.height / 2;

            if (shapeToUpdate.type === 'circle') {
                const originalCenter = new THREE.Vector3(preTransformState.shape.center.x + offsetX, 0, preTransformState.shape.center.y + offsetZ);
                const newCenter = originalCenter.clone().applyMatrix4(transformMatrix);

                shapeToUpdate.center.x = newCenter.x - offsetX;
                shapeToUpdate.center.y = newCenter.z - offsetZ;

                const scaleVec = new THREE.Vector3();
                transformMatrix.decompose(new THREE.Vector3(), new THREE.Quaternion(), scaleVec);
                shapeToUpdate.radius = preTransformState.shape.radius * ((scaleVec.x + scaleVec.z) / 2);
            } else {
                shapeToUpdate.points = preTransformState.shape.points.map(p => {
                    const vec = new THREE.Vector3(p.x, 0, p.y);
                    vec.applyMatrix4(transformMatrix);
                    return { x: vec.x, y: vec.z };
                });
            }

            transformControls.detach();
            update3DScene();
            drawAllShapes();
            updateJsonEditor();
            preTransformState = {};
        }


        // --- MAIN EXECUTION ---
        init2D();
        init3D();
        initResizers();
        renderFileTree();
        update3DScene();
        updateJsonEditor();
        setTool('rectangle'); // Set default tool
        setActiveTransformTool('translate'); // Set default transform tool
    </script>
</body>
</html>
