<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D CAD to 3D Real-time Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrolling of the entire page */
        }
        #main-container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        #panel-2d {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: #f8fafc;
            border-right: 1px solid #e2e8f0;
        }
        #toolbar {
            padding: 0.5rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: #ffffff;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        #toolbar button {
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            border: 1px solid #cbd5e1;
            background-color: #ffffff;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        #toolbar button:hover {
            background-color: #f1f5f9;
            border-color: #94a3b8;
        }
        #toolbar button.active {
            background-color: #4f46e5;
            color: #ffffff;
            border-color: #4f46e5;
        }
        #canvas-container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
        }
        #drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }
        #panel-3d {
            flex: 1;
            position: relative;
            background-color: #e0e0e0;
        }
        #renderer-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        .info-box {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div id="main-container">
        <!-- 2D Panel -->
        <div id="panel-2d">
            <div id="toolbar">
                <button id="tool-wall" class="active">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-bounding-box" viewBox="0 0 16 16">
                        <path d="M5 2V0H0v5h2v6H0v5h5v-2h6v2h5v-5h-2V5h2V0h-5v2H5zm6 1v2h2v6h-2v2h4V5h-4zM1 1h2v2H1V1zm2 12H1v2h2v-2zM13 1h2v2h-2V1zm2 12h-2v2h2v-2zM0 5h1v6H0V5zm15 0h1v6h-1V5zM3 3H1V1h2v2zm10 0h2V1h-2v2zM3 13H1v2h2v-2zm10 0h2v-2h-2v2z"/>
                    </svg>
                    Wall
                </button>
                 <button id="tool-clear">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                        <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                        <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                    </svg>
                    Clear All
                </button>
            </div>
            <div id="canvas-container">
                <canvas id="drawing-canvas"></canvas>
            </div>
        </div>

        <!-- 3D Panel -->
        <div id="panel-3d">
            <div id="renderer-container"></div>
            <div class="info-box">
                <b>3D View:</b> Click+Drag = Orbit | Right-Click+Drag = Pan | Scroll = Zoom
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- GLOBAL STATE ---
        let scene, camera, renderer, controls, wallGroup;
        const shapes = []; // Data store for 2D shapes: {x, y, width, height}
        const WALL_HEIGHT = 50;
        const WALL_THICKNESS = 8;

        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container');

        let isDrawing = false;
        let startPoint = { x: 0, y: 0 };
        
        // --- 3D SCENE INITIALIZATION ---
        function init3D() {
            const container = document.getElementById('renderer-container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 1, 5000);
            camera.position.set(200, 200, 200);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.screenSpacePanning = true; // Use right-click to pan

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 200, 150);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 180;
            dirLight.shadow.camera.bottom = -120;
            dirLight.shadow.camera.left = -120;
            dirLight.shadow.camera.right = 120;
            scene.add(dirLight);

            // Ground Plane
            const groundGeo = new THREE.PlaneGeometry(2000, 2000);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.8 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid Helper
            const gridHelper = new THREE.GridHelper(2000, 100, 0x000000, 0x000000);
            gridHelper.material.opacity = 0.15;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // Wall Group
            wallGroup = new THREE.Group();
            scene.add(wallGroup);

            // Animation Loop
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- 2D CANVAS INITIALIZATION ---
        function init2D() {
            resizeCanvas();
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseLeave);
        }

        function resizeCanvas() {
            const rect = canvasContainer.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            drawAllShapes();
        }

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        // --- DRAWING LOGIC ---
        function onMouseDown(e) {
            if (e.button !== 0) return; // Only respond to left-click
            isDrawing = true;
            startPoint = getMousePos(e);
        }

        function onMouseMove(e) {
            if (!isDrawing) return;
            const currentPos = getMousePos(e);
            
            // Clear and redraw existing shapes
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawAllShapes();

            // Draw preview of the new wall
            ctx.fillStyle = 'rgba(79, 70, 229, 0.3)'; // Semi-transparent preview
            ctx.strokeStyle = 'rgba(79, 70, 229, 0.8)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.rect(startPoint.x, startPoint.y, currentPos.x - startPoint.x, currentPos.y - startPoint.y);
            ctx.fill();
            ctx.stroke();
        }

        function onMouseUp(e) {
            if (!isDrawing) return;
            isDrawing = false;
            const endPoint = getMousePos(e);

            const newWall = {
                x: Math.min(startPoint.x, endPoint.x),
                y: Math.min(startPoint.y, endPoint.y),
                width: Math.abs(startPoint.x - endPoint.x),
                height: Math.abs(startPoint.y - endPoint.y)
            };

            // Only add shape if it has a meaningful size
            if (newWall.width > 2 && newWall.height > 2) {
                shapes.push(newWall);
            }

            drawAllShapes();
            update3DScene();
        }

        function onMouseLeave() {
            if(isDrawing) {
                isDrawing = false;
                drawAllShapes(); // Clean up preview rect if mouse leaves while drawing
            }
        }

        function drawAllShapes() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#334155';
            ctx.fillStyle = '#e2e8f0';
            ctx.lineWidth = 2;
            
            shapes.forEach(shape => {
                ctx.beginPath();
                ctx.rect(shape.x, shape.y, shape.width, shape.height);
                ctx.fill();
                ctx.stroke();
            });
        }

        // --- SYNCHRONIZATION LOGIC ---
        function update3DScene() {
            // Clear existing walls from the 3D scene
            while (wallGroup.children.length) {
                wallGroup.remove(wallGroup.children[0]);
            }

            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.7,
                metalness: 0.1
            });
            
            // This offset centers the 2D drawing in the 3D world
            const offsetX = -canvas.width / 2;
            const offsetZ = -canvas.height / 2;

            shapes.forEach(shape => {
                // Determine if it's a horizontal or vertical wall based on aspect ratio
                const isHorizontal = shape.width >= shape.height;
                const geometry = isHorizontal 
                    ? new THREE.BoxGeometry(shape.width, WALL_HEIGHT, WALL_THICKNESS)
                    : new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, shape.height);

                const wallMesh = new THREE.Mesh(geometry, wallMaterial.clone());
                wallMesh.castShadow = true;
                wallMesh.receiveShadow = true;
                
                // Position the mesh based on the 2D rect's center
                const centerX = shape.x + shape.width / 2;
                const centerZ = shape.y + shape.height / 2; // 2D 'y' maps to 3D 'z'
                
                wallMesh.position.set(
                    centerX + offsetX,
                    WALL_HEIGHT / 2, // Place it on top of the ground plane
                    centerZ + offsetZ
                );

                wallGroup.add(wallMesh);
            });
        }

        // --- EVENT LISTENERS ---
        window.addEventListener('resize', () => {
            // 2D Canvas
            resizeCanvas();
            
            // 3D Renderer
            const container = document.getElementById('renderer-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);

            // Sync 3D view after resize
            update3DScene();
        });
        
        document.getElementById('tool-clear').addEventListener('click', () => {
            shapes.length = 0; // Clear the array
            drawAllShapes();
            update3DScene();
        });


        // --- MAIN EXECUTION ---
        init2D();
        init3D();
        update3DScene(); // Initial sync in case there's saved data later
    </script>
</body>
</html>
